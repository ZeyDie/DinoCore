package net.minecraft.network;

import com.zeydie.netty.handlers.NettyPacketInboundHandler;
import com.zeydie.netty.handlers.NettyPacketOutboundHandler;
import com.zeydie.netty.wrappers.NettyPacketWrapperLegacy;
import com.zeydie.settings.optimization.CoreSettings;
import com.zeydie.settings.optimization.NettySettings;
import cpw.mods.fml.common.network.FMLNetworkHandler;
import io.netty.channel.socket.SocketChannel;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.network.packet.*;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.dedicated.DedicatedServerListenThread;
import net.minecraft.server.management.ServerConfigurationManager;
import net.minecraft.util.StringUtils;
import org.jetbrains.annotations.NotNull;

import javax.crypto.SecretKey;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Arrays;
import java.util.Random;

public class NetLoginHandler extends NetHandler {
    /**
     * The Random object used to generate serverId hex strings.
     */
    private static Random rand = new Random();

    /**
     * The 4 byte verify token read from a Packet252SharedKey
     */
    private byte[] verifyToken;

    /**
     * Reference to the MinecraftServer object.
     */
    private final MinecraftServer mcServer;
    public final TcpConnection myTCPConnection;
    public boolean connectionComplete;
    private int connectionTimer;
    public String clientUsername;
    private volatile boolean field_72544_i;

    /**
     * server ID that is randomly generated by this login handler.
     */
    private String loginServerId = Long.toString(rand.nextLong(), 16); // CraftBukkit - Security fix
    private boolean field_92079_k;

    /**
     * Secret AES key obtained from the client's Packet252SharedKey
     */
    private SecretKey sharedKey;
    public String hostname = ""; // CraftBukkit - add field

    //TODO ZeyCodeStart
    public NetLoginHandler(
            @NotNull final MinecraftServer minecraftServer,
            @NotNull final SocketChannel socketChannel,
            @NotNull final String reason
    ) {
        this.mcServer = minecraftServer;
        this.myTCPConnection = new TcpConnection(socketChannel, reason, this, minecraftServer.getKeyPair().getPrivate());
    }
    //TODO ZeyCodeEnd

    public NetLoginHandler(MinecraftServer par1MinecraftServer, Socket par2Socket, String par3Str) throws IOException {
        this.mcServer = par1MinecraftServer;
        this.myTCPConnection = new TcpConnection(par1MinecraftServer.getLogAgent(), par2Socket, par3Str, this, par1MinecraftServer.getKeyPair().getPrivate());
        this.myTCPConnection.field_74468_e = 0;
    }

    // CraftBukkit start
    public Socket getSocket() {
        if (this.myTCPConnection == null)
            return null;
        return this.myTCPConnection.getSocket();
    }
    // CraftBukkit end

    /**
     * Logs the user in if a login packet is found, otherwise keeps processing network packets unless the timeout has
     * occurred.
     */
    public void tryLogin() {
        if (this.field_72544_i) {
            this.initializePlayerConnection();
        }

        if (this.connectionTimer++ == 6000) {
            this.raiseErrorAndDisconnect("Took too long to log in");
        } else {
            this.myTCPConnection.processReadPackets();
        }
    }

    public void raiseErrorAndDisconnect(String par1Str) {
        try {
            this.mcServer.getLogAgent().logInfo("Disconnecting " + this.getUsernameAndAddress() + ": " + par1Str);
            this.myTCPConnection.addToSendQueue(new Packet255KickDisconnect(par1Str));
            this.myTCPConnection.serverShutdown();
            this.connectionComplete = true;
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }

    private static final java.util.regex.Pattern validName = java.util.regex.Pattern.compile("^[a-zA-Z0-9_-]{2,16}$"); // Spigot

    public void handleClientProtocol(Packet2ClientProtocol par1Packet2ClientProtocol) {
        if (this.clientUsername != null) {
            this.raiseErrorAndDisconnect("Quit repeating yourself!");
        } else {
            this.hostname = par1Packet2ClientProtocol.serverHost + ':' + par1Packet2ClientProtocol.serverPort; // CraftBukkit - initialize field
            this.clientUsername = par1Packet2ClientProtocol.getUsername();

            if (!this.clientUsername.equals(StringUtils.stripControlCodes(this.clientUsername)) || !validName.matcher(this.clientUsername).matches()) // Spigot
            {
                this.raiseErrorAndDisconnect("Invalid username!");
            } else {
                PublicKey publickey = this.mcServer.getKeyPair().getPublic();

                if (par1Packet2ClientProtocol.getProtocolVersion() != 78) {
                    if (par1Packet2ClientProtocol.getProtocolVersion() > 78) {
                        this.raiseErrorAndDisconnect(org.spigotmc.SpigotConfig.outdatedServerMessage); // Spigot
                    } else {
                        this.raiseErrorAndDisconnect(org.spigotmc.SpigotConfig.outdatedClientMessage); // Spigot
                    }
                } else {
                    this.loginServerId = this.mcServer.isServerInOnlineMode() ? Long.toString(rand.nextLong(), 16) : "-";
                    this.verifyToken = new byte[4];
                    rand.nextBytes(this.verifyToken);
                    this.myTCPConnection.addToSendQueue(new Packet253ServerAuthData(this.loginServerId, publickey, this.verifyToken));
                }
            }
        }
    }

    public void handleSharedKey(Packet252SharedKey par1Packet252SharedKey) {
        PrivateKey privatekey = this.mcServer.getKeyPair().getPrivate();
        this.sharedKey = par1Packet252SharedKey.getSharedKey(privatekey);

        if (!Arrays.equals(this.verifyToken, par1Packet252SharedKey.getVerifyToken(privatekey))) {
            this.raiseErrorAndDisconnect("Invalid client reply");
        }

        this.myTCPConnection.addToSendQueue(new Packet252SharedKey());
    }

    public void handleClientCommand(Packet205ClientCommand par1Packet205ClientCommand) {
        if (par1Packet205ClientCommand.forceRespawn == 0) {
            if (this.field_92079_k) {
                this.raiseErrorAndDisconnect("Duplicate login");
                return;
            }

            this.field_92079_k = true;

            if (this.mcServer.isServerInOnlineMode()) {
                (new ThreadLoginVerifier(this, mcServer.server)).start(); // CraftBukkit - add CraftServer
            } else {
                this.field_72544_i = true;
            }
        }
    }

    public void handleLogin(Packet1Login par1Packet1Login) {
        FMLNetworkHandler.handleLoginPacketOnServer(this, par1Packet1Login);
    }

    /**
     * on success the specified username is connected to the minecraftInstance, otherwise they are packet255'd
     */
    public void initializePlayerConnection() {
        FMLNetworkHandler.onConnectionReceivedFromClient(this, this.mcServer, this.myTCPConnection.getSocketAddress(), this.clientUsername);
    }

    public void completeConnection(String s) {
        if (s != null) {
            this.raiseErrorAndDisconnect(s);
        } else {
            // CraftBukkit start
            EntityPlayerMP entityplayermp = this.mcServer.getConfigurationManager().attemptLogin(this, this.clientUsername, this.hostname);

            if (entityplayermp == null) {
                return;
                // CraftBukkit end
            } else {
                entityplayermp = this.mcServer.getConfigurationManager().processLogin(entityplayermp); // CraftBukkit - this.h -> s // Cauldron - reuse variable

                if (entityplayermp != null) {

                    //TODO ZeyCodeStart
                    if (NettySettings.getInstance().getSettings().isEnable()) {
                        this.myTCPConnection.socketChannel
                                .pipeline()
                                .addAfter(
                                        "decoder",
                                        "inboundHandler",
                                        new NettyPacketInboundHandler(
                                                this.clientUsername,
                                                entityplayermp.getUniqueID()
                                        )
                                );
                        this.myTCPConnection.socketChannel
                                .pipeline()
                                .addBefore(
                                        "encoder",
                                        "outboundHandler",
                                        new NettyPacketOutboundHandler(
                                                this.clientUsername,
                                                entityplayermp.getUniqueID()
                                        )
                                );
                    }
                    //TODO ZeyCodeEnd

                    this.mcServer.getConfigurationManager().initializeConnectionToPlayer((INetworkManager) this.myTCPConnection, entityplayermp);
                }
            }
        }

        this.connectionComplete = true;
    }

    public void handleErrorMessage(String par1Str, Object[] par2ArrayOfObj) {
        //TODO ZeyCodeClear
        //this.mcServer.getLogAgent().logInfo(this.getUsernameAndAddress() + " lost connection");
        //TODO ZeyCodeStart
        this.mcServer.getLogAgent().logInfo(this.getUsernameAndAddress() + " lost connection " + par1Str);
        //TODO ZeyCodeEnd
        this.connectionComplete = true;
    }

    /**
     * Handle a server ping packet.
     */
    public void handleServerPing(Packet254ServerPing par1Packet254ServerPing) {
        if (this.getSocket() == null) // Cauldron - remove myTCPConnection
        {
            return;    // CraftBukkit - fix NPE when a client queries a server that is unable to handle it.
        }

        try {
            ServerConfigurationManager serverconfigurationmanager = this.mcServer.getConfigurationManager();
            String s = null;
            // CraftBukkit
            org.bukkit.event.server.ServerListPingEvent pingEvent = org.bukkit.craftbukkit.v1_6_R3.event.CraftEventFactory.callServerListPingEvent(this.mcServer.server, getSocket().getInetAddress(), this.mcServer.getMOTD(), serverconfigurationmanager.getCurrentPlayerCount(), serverconfigurationmanager.getMaxPlayers());

            if (par1Packet254ServerPing.func_140050_d()) {
                // CraftBukkit
                s = pingEvent.getMotd() + "\u00A7" + serverconfigurationmanager.getCurrentPlayerCount() + "\u00A7" + pingEvent.getMaxPlayers();
            } else {
                // CraftBukkit start - Don't create a list from an array
                Object[] list = new Object[]{1, 78, this.mcServer.getMinecraftVersion(), pingEvent.getMotd(), serverconfigurationmanager.getCurrentPlayerCount(), pingEvent.getMaxPlayers()};
                StringBuilder builder = new StringBuilder();

                for (Object object : list) {
                    if (builder.length() == 0) {
                        builder.append('\u00A7');
                    } else {
                        builder.append('\0');
                    }

                    builder.append(org.apache.commons.lang.StringUtils.replace(object.toString(), "\0", ""));
                }

                s = builder.toString();
                // CraftBukkit end
            }

            //TODO ZeyCodeStart
            if (NettySettings.getInstance().getSettings().isEnable())
                this.myTCPConnection.socketChannel
                        .pipeline()
                        .replace(
                                "wrapper",
                                "wrapper_legacy",
                                new NettyPacketWrapperLegacy()
                        );
            //TODO ZeyCodeEnd

            InetAddress inetaddress = null;

            if (this.getSocket() != null) {
                inetaddress = this.getSocket().getInetAddress();
            }

            this.myTCPConnection.addToSendQueue(new Packet255KickDisconnect(s));
            this.myTCPConnection.serverShutdown();

            if (inetaddress != null && this.mcServer.getNetworkThread() instanceof DedicatedServerListenThread) {
                ((DedicatedServerListenThread) this.mcServer.getNetworkThread()).func_71761_a(inetaddress);
            }

            this.connectionComplete = true;
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }

    /**
     * Default handler called for packets that don't have their own handlers in NetClientHandler; currentlly does
     * nothing.
     */
    public void unexpectedPacket(Packet par1Packet) {
        this.raiseErrorAndDisconnect("Protocol error");
    }

    public String getUsernameAndAddress() {
        return this.clientUsername != null ? this.clientUsername + " [" + this.myTCPConnection.getSocketAddress().toString() + "]" : this.myTCPConnection.getSocketAddress().toString();
    }

    /**
     * determine if it is a server handler
     */
    public boolean isServerHandler() {
        return true;
    }

    public boolean isConnectionClosed() {
        return this.connectionComplete;
    }

    /**
     * Returns the server Id randomly generated by this login handler.
     */
    static String getServerId(NetLoginHandler par0NetLoginHandler) {
        return par0NetLoginHandler.loginServerId;
    }

    /**
     * Returns the reference to Minecraft Server.
     */
    //TODO ZoomCodeReplace private on public
    public static MinecraftServer getLoginMinecraftServer(NetLoginHandler par0NetLoginHandler) {
        return par0NetLoginHandler.mcServer;
    }

    /**
     * Return the secret AES sharedKey
     */
    static SecretKey getSharedKey(NetLoginHandler par0NetLoginHandler) {
        return par0NetLoginHandler.sharedKey;
    }

    /**
     * Returns the connecting client username.
     */
    //TODO ZoomCodeReplace private on public
    public static String getClientUsername(NetLoginHandler par0NetLoginHandler) {
        return par0NetLoginHandler.clientUsername;
    }

    public static boolean func_72531_a(NetLoginHandler par0NetLoginHandler, boolean par1) {
        return par0NetLoginHandler.field_72544_i = par1;
    }

    // Spigot start
    @Override
    public void handleCustomPayload(Packet250CustomPayload par1Packet250CustomPayload) {
        if (par1Packet250CustomPayload.channel.equals("BungeeCord") && org.spigotmc.SpigotConfig.bungee && getSocket() != null && getSocket().getInetAddress() != null && org.spigotmc.SpigotConfig.bungeeAddresses.contains(getSocket().getInetAddress().getHostAddress())) {
            com.google.common.io.ByteArrayDataInput in = com.google.common.io.ByteStreams.newDataInput(par1Packet250CustomPayload.data);
            String subTag = in.readUTF();

            if (subTag.equals("Login")) {
                myTCPConnection.setSocketAddress(new java.net.InetSocketAddress(in.readUTF(), in.readInt()));
            }
        }

        FMLNetworkHandler.handlePacket250Packet(par1Packet250CustomPayload, myTCPConnection, this);  // Cauldron
    }
    // Spigot end    

    @Override
    public void handleVanilla250Packet(Packet250CustomPayload payload) {
        // NOOP for login
    }

    @Override
    public EntityPlayer getPlayer() {
        return null;
    }
}
